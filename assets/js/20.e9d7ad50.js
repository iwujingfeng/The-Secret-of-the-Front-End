(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{174:function(e,t,r){"use strict";r.r(t);var s=r(0),i=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"简述vue的响应式原理并进行简单实现？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简述vue的响应式原理并进行简单实现？","aria-hidden":"true"}},[this._v("#")]),this._v(" 简述Vue的响应式原理并进行简单实现？")]),this._v(" "),t("p",[this._v("当我们定义 Vue 实例作为 data 选项时，会传入一个 JavaScript 对象。Vue 会遍历该对象的所有属性，并且用Object.defineProperty把属性全部转化为 getter、setter。这些getter、setter 会让 Vue 追踪依赖，在属性被访问和修改时通知变更。需要注意的是，Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因，也就是说，IE8无法使用旧的api来模拟实现这个特性。同时，在使用 Object.defineProperty 时，get 和set 函数是存取描述符，value 和writable 函数是数据描述符。描述符必须是这两种形式之一，但二者不能共存，不然会出现异常。")]),this._v(" "),t("p",[this._v("每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。")])])}],!1,null,null,null);t.default=i.exports}}]);